(defun fft (data steps)
    (let ((n (length data)))
        (loop
            (when (<= steps 0) (return))
            (decf steps)
            (let ((sum (aref data (1- n))) sign-count)
                (loop for i from (- n 2) downto 0 do
                    (incf sum (aref data i))
                    (setf (aref data i) sum)
                )
                (loop for i below n do
                    (setq sum (aref data i) sign-count 0)
                    (loop for k from (+ i i 1) below n by (1+ i) do
                        (if (>= sign-count 2)
                            (incf sum (aref data k))
                            (decf sum (aref data k))
                        )
                        (if (= sign-count 3)
                            (setq sign-count 0)
                            (incf sign-count)
                        )
                    )
                    (setf (aref data i) (abs (rem sum 10)))
                )
            )
        )
    )
)

(let ((data nil))
    (with-open-file (input-stream "input")
        (let (
                (conversion-table (make-hash-table))
                (input (read-line input-stream))
            )
            (map nil (lambda (k v) (setf (gethash k conversion-table) v)) "0123456789" '(0 1 2 3 4 5 6 7 8 9))
            (setq data (make-array (list (length input)) :element-type 'integer))
            (map-into data (lambda (k) (gethash k conversion-table)) input)
        )
    )
    (fft data 100)
    (loop for i below 8 do (princ (aref data i)))
    (terpri)
)